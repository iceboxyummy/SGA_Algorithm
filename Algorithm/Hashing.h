#pragma once

// Hashing.h

/*
	Hashing(해싱)

		사용처
			1. 보안 : 데이터의 위변조를 막기 위해 전자 서명이나 보안 알고리즘에 사용
			2. 자료 구조 : 기억 공간에 저장된 정보를 보다 빠르게 검색하기 위해서 절대 주소나
			상대주소가 아닌 해시 테이블을 생성 방식이다.

			대부분의 탐색 방법들은 탐색 키를 저장된 키 값과 반복적으로
			비교해가면서 탐색을 원하는 항목에 접근하게 된다.
			반면 해싱은 키값에 직접 산술적인 연산을 적용하여 항목이 저장되어 있는
			테이블의 주소를 계산하여 항목에 접근한다.

			이렇게 키 값의 연산에 의해 직접 접근이 가능한 구조를
			해시 테이블이라고 부르고, 해시 테이블을 이용한 탐색을 해싱이라고 한다.

			키들의 비교에 의한 탐색 방법은 정렬이 되어있지 않다면. O(N)이고
			정렬이 되어 있으면 O(log(n))이다.

			하지만 해싱은 이론적으로 O(1)의 시간만에 탐색을 마칠수 있다.
			dictionary(사전구조)와 같은 자료구조를 구현할 때 최상의 선택이 된다.

			사전 구조는 map 혹은 table 이라고 부른다.
			사전 구조는 탐색 키, 탐색 키와 관련있는 값(데이터) 이렇게
			2가지 종류의 필드를 가진다.

	용어 정리

		해시함수(hashing function)
			- 키값으로부터 레코드의 물리적 주소로 사상시키는 함수.
			- 데이터 무결성 검증. 변조 여부 파악을 위해 임의 길이 메세지를 고정길이 매세지로
			변환시 사용한 단방향 함수.
		해시 키(hash key)
			- 해싱 함수가 레코드 주소를 계산하기 위해 사용하는 레코드의 키 값.
		해시 테이블(hash table)
			- 해싱 함수에 의해 계산된 주소
			- 키 연산에 의해 직접 접근이 가능 구조의 기억장소.
		버킷(bucket)
			- 하나의 주소를 가지면서 하나 이상의 레코드를 저장할 수 있는 파일의 한 구역.
			- 여러개의 슬롯으로 구성됨.
		슬롯(slot)
			- 한개의 레코드를 저장 할 수 있는 공간
		직접 파일(direct file)
			- 해싱 방법을 기초로 하여 만들어진 파일
		충돌
			- 서로 다른 레코드들이 같은 주소로 변환되는 경우
		오버 플로우
		 - 더 이상 빈자리가 없는 과잉상태
		 - 버킷에 레코드들이 가득 찬 상태

	해시 함수 구현 기법.

		정적 해싱
			고정 크기의 배열을 이용한 방법.
			버킷 주소의 집합을 고정한다.
			현재 파일의 크기를 고려하여 해시 함수를 결정한다.
			미래의 어떤 시점을 기점으로 파일 크기를 예상하여 해시함수를 결정한다.
			파일의 크기가 커짐에 따라 주기적으로 해싱 구조를 재구성해야 한다.
			구현이 쉽고 간단
			**버킷의 크기를 너무 작게 잡으면 충돌의 우려가 있고,
				너무 크게 잡으면 메모리 낭비가 있다.

			- 제산법(Division)
			해시된 주소가 고르게 분포되지 않을 수 있기 때문에 일반적으로
			전체 버킷의 크기를 소수(Prime number)로 하여 성능을 향상시킨다.

			- 중간 제곱법(mid-sqare)
			제곱된 결과의 중간 비트는 일반적으로 모든 키 값의 모든 문자에 영향을 받기 때문
			키를 구성하는 일부 문자가 같을지라도 서로 다른 결과 값을 가질 확률이 높다.

			- 폴딩법(folding)
				이동폴딩 / 경계폴딩법 존재

			- 숫자 분석법(digit-analysis)
				파일의 키값이 이미 알려진 정적파일인 경우에 유용하며,
				삽입과 삭제가 번번히 발생하는 경우에는 비효율적이다.

			- 기수 변환법(radix-exchange)
			변환된 해당 버킷 주소가 배열의 크기를 초과 할 경우, 버킷 주소의 최하위
			자리부터 배열의 크기가 허용하는 자리수 만큼 취하여 버킷주소로 이용한다.

			- 무작위 방법
				충돌이 발생하면 그 다음 난수를 버킷 주소로 할 수 있다.

		동적 해싱(dynamic hashing)
			- 동적 해싱은 데이터의 증감에 따라 배열의 크기를 동적으로 변화시키며
			오버플로우 발생 시 테이블의 크기를 2배수로 확장을 한다.
			- 버킷의 수를 유동적으로 관리하며 해싱된 키를 인덱스로 사용하는 이진트리를
			동적을 변환하여 사용한다.
			- 데이터의 증감에 따라 버킷을 쪼개거나 합치고 버킷을 포인터로 가리키는 인덱스 테이블을
			추가적으로 사용한다.
			- 데이터가 증가해도 검색의 성능이 유지가 되며, 메모리의 낭비가 적다.
			접근 시간을 일정하게 유지할수 있다.
			- 해시테이블 대신에 trie(트라이) 자료구조를 이용한다.

		확장 해싱(extendible hashing)
		 - 인덱스의 구조를 조절하기 위해서 해시 함수의 동적 변경을 허용함.
		 - 디렉터리와 버킷으로 구성된 2단계 구조임.

		충돌이 났을때
		  개방 주소법 : overflow발생시 다른 주소를 반복적으로 탐색하는 기법.
				- 선형 검색법(linear probing) : 충돌 위치에서 테이블 순으로 순차검색. 1차원 배열구조.
				- 2차 검색법(quadratic probing) : 선형 검색법의 제 1밀집현상을 해소하기 위한 기법
												원래 주소로부터 다음 주소를 결정하는 거리가
												1, 4, 5, 16의 떨어진 거리만큼 차례대로 검색
				- 이중해싱법(double hasing) : 해시값을 해싱함수에 다시 집어넣는 방법.
				- 무작위 검색법(random probing) : 빈 주소 공간을 찾을 때까지 난수 계산프로그램을 돌리는 방법.
			패쇄 주소법
				- 해시 체이닝(hash chaining) : 충돌이 발생한 레코드들을 연결리스트로 연결
											테이블은 포인터 배열로 만들고 각 버킷에 할당되는
											레코드들을 체인으로 연결하는 방법
				- 독립 오버플로우 구역(chaining with separate overflow area)
				: 오버플로우된 레코드들을 별도의 오버플로우 지역에 저장
				오버플로우된 레코드를 처리하는 기법중에 가장 많이 쓰인다.

*/